# Day 4: Gate-Level Simulation, RTL-to-Gates Flow, and Debugging Synthesis Mismatches

Welcome to **Day 4** of the **RISC-V SoC Tapeout Program**.  
In this session, we dive deeper into the verification flow after synthesis and understand how **RTL transforms into gates** using standard cell libraries. We will also analyze **common pitfalls** and how to debug mismatches effectively.

---

## üìå Topics Covered
1. Gate-Level Simulation (GLS) in the SoC design flow  
2. RTL-to-Gates: How Yosys + Liberty + Verilog models connect  
3. Synthesis-Simulation mismatches and their real causes  
4. Delay annotation and functional vs timing simulations  
5. Hands-on labs with practical case studies  

---

## 1Ô∏è‚É£ Gate-Level Simulation (GLS)

GLS is the process of simulating the **post-synthesis netlist** generated from your RTL.  
Unlike pure RTL simulation, GLS validates the design against **realistic hardware cells** from the PDK.

‚úÖ **Why GLS is important:**
- Ensures the netlist generated by synthesis tools preserves RTL behavior.  
- Exposes bugs due to incomplete coding, inferred latches, or wrong assumptions.  
- Allows timing verification (when SDF delays are back-annotated).  
- Confirms the integration of standard cells from **Sky130** library into your design.  

üîë **Types of GLS**:
- **Zero/Unit Delay GLS** ‚Üí Quick functional check (no real timing).  
- **SDF Timing GLS** ‚Üí Real-world delay simulation with annotated `.sdf` files.  

---

## 2Ô∏è‚É£ RTL ‚Üí Gates Flow

The process from RTL to gates can be summarized as:

RTL (Verilog) ‚Üí Yosys Synthesis ‚Üí Netlist (with Sky130 Cells) ‚Üí Gate-Level Simulation


- **RTL (Behavioral Design):** Human-readable hardware description.  
- **Yosys Synthesis:** Optimizes logic, maps it to available standard cells in `.lib`.  
- **Netlist:** Structural Verilog composed of gates from `sky130_fd_sc_hd.v`.  
- **Simulation:** Done using `iverilog` with standard cell models.  

---

## 3Ô∏è‚É£ Synthesis-Simulation Mismatch

Sometimes the RTL sim and GLS sim give different results. Reasons include:  

- ‚ùå **Non-synthesizable constructs**: `#delays`, `initial`, `$display`.  
- ‚ùå **Incomplete sensitivity list**: Missing signals in `always @(...)`.  
- ‚ùå **Latch inference**: If variables aren‚Äôt assigned in all branches.  
- ‚ùå **Tool interpretation differences**: Yosys vs Icarus may optimize differently.  

üëâ **Golden Rule:** Write **synthesizable, deterministic RTL** with full coverage.  

---

## 4Ô∏è‚É£ Delay Annotation (SDF Basics)

In real silicon, gates don‚Äôt switch instantly. GLS can include **Standard Delay Format (SDF)** files that capture:  
- Gate delays  
- Setup/Hold timing checks  
- Interconnect delays  

For now, we focus on **functional GLS (no SDF)**, but in tapeout, timing GLS is crucial for **sign-off**.

---

## 5Ô∏è‚É£ Labs

###  Lab 1: Simple MUX GLS
- Write a 2:1 mux in RTL.  
- Synthesize using Yosys ‚Üí netlist.  
- Run GLS with:  
  ```bash
  iverilog primitives.v sky130_fd_sc_hd.v mux_netlist.v tb_mux.v -o gls_mux
  vvp gls_mux
  gtkwave tb_mux.vcd


Lab 2: D-Flipflop GLS

RTL: always @(posedge clk) q <= d;

Check GLS output waveform vs RTL.

Observe how reset and initialization differ in GLS.

 Lab 3: Debugging Mismatches

Write a module with an incomplete if-else.

Observe mismatch between RTL sim and GLS sim.

Fix the RTL ‚Üí verify again with GLS.

 Lab 4: Timing GLS (Optional Advanced)

Generate an .sdf file from synthesis tool.

Run simulation with SDF annotation in iverilog.

Observe realistic delays on waveforms.

 Key Takeaways

GLS is a must-have step before tapeout to ensure design correctness.

Functional GLS validates logical correctness; Timing GLS validates real-world behavior.

Always write synthesizable RTL to avoid hidden bugs.

Cross-check RTL vs Netlist vs GLS waveforms for confidence.

 Summary

Learned GLS concepts and flow.

Explored synthesis-simulation mismatches and fixes.

Practiced GLS on MUX and DFF modules.

Peeked into SDF-based timing simulations.

